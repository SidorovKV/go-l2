package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/

type DBConnectable interface {
	Connect()
	Disconnect()
}

type SqlDb struct {
	address string
}

func (s *SqlDb) Connect() {
	fmt.Println("Connect to SQL DB at", s.address)
}

func (s *SqlDb) Disconnect() {
	fmt.Println("Disconnect from SQL DB")
}

type CsvDb struct {
	path string
}

func (c *CsvDb) Connect() {
	fmt.Println("Open CSV file at", c.path)
}

func (c *CsvDb) Disconnect() {
	fmt.Println("Close CSV file")
}

type DataService struct {
	db DBConnectable
}

func (d *DataService) SetDbConnection(connectable DBConnectable) {
	d.db = connectable
}

func StrategyExample() {
	sqlDb := &SqlDb{address: "localhost"}
	csvDb := &CsvDb{path: "data.csv"}

	dataService := DataService{sqlDb}
	dataService.db.Connect()
	dataService.db.Disconnect()

	dataService.SetDbConnection(csvDb)
	dataService.db.Connect()
	dataService.db.Disconnect()

}

/*
Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов
и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время
исполнения программы.

Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются,
и вынести их в собственные классы, называемые стратегиями.

Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста,
ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм,
нам будет достаточно подставить в контекст другой объект-стратегию.

Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым
от конкретных классов стратегий. С другой стороны, мы сможем изменять и добавлять новые виды алгоритмов,
не трогая код контекста.

Применимость
- Когда нам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.

Стратегия позволяет варьировать поведение объекта во время выполнения программы,
подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).

- Когда у нас есть множество похожих классов, отличающихся только некоторым поведением.

Стратегия позволяет вынести отличающееся поведение в отдельную иерархию классов,
а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым.

- Когда мы не хотим обнажать детали реализации алгоритмов перед другими классами.

Стратегия позволяет изолировать код, данные и зависимости алгоритмов от других объектов,
скрыв эти детали внутри классов-стратегий.

- Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора.
Каждая ветка такого оператора представляет собой вариацию алгоритма.

Стратегия помещает каждую ветвь такого оператора в отдельный класс-стратегию.
Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу.
Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.

Преимущества
- Горячая замена алгоритмов на лету.
- Изолирует код и данные алгоритмов от остальных классов.
- Уход от наследования к делегированию.
- Реализует принцип открытости/закрытости.

Недостатки
- Усложняет программу за счёт дополнительных классов.
- Клиент должен знать, в чём состоит разница между стратегиями, чтобы выбрать подходящую.
*/
