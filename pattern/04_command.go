package pattern

import "fmt"

/*
	Реализовать паттерн «комманда».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Command_pattern
*/

type Command interface {
	execute()
}

type Actor struct {
	Command
}

func (a *Actor) action() {
	a.execute()
}

type Actions interface {
	action1()
	action2()
	action3()
}

type Action1Command struct {
	Actions
}

func (a *Action1Command) execute() {
	a.action1()
}

type Action2Command struct {
	Actions
}

func (a *Action2Command) execute() {
	a.action2()
}

type Action3Command struct {
	Actions
}

func (a *Action3Command) execute() {
	a.action3()
}

type ConcreteActor struct{}

func (c *ConcreteActor) action1() {
	fmt.Println("action1")
}

func (c *ConcreteActor) action2() {
	fmt.Println("action2")
}

func (c *ConcreteActor) action3() {
	fmt.Println("action3")
}

type AnotherConcreteActor struct{}

func (c *AnotherConcreteActor) action1() {
	fmt.Println("action1 by AnotherConcreteActor")
}

func (c *AnotherConcreteActor) action2() {
	fmt.Println("action2 by AnotherConcreteActor")
}

func (c *AnotherConcreteActor) action3() {
	fmt.Println("action3 by AnotherConcreteActor")
}

func CommandExample() {
	concreteActor := &ConcreteActor{}
	anotherConcreteActor := &AnotherConcreteActor{}
	actor := Actor{&Action1Command{concreteActor}}
	actor.action()
	actor.Command = &Action3Command{anotherConcreteActor}
	actor.action()
	actor.Command = &Action2Command{concreteActor}
	actor.action()
	actor.Command = &Action1Command{anotherConcreteActor}
	actor.action()
	actor.Command = &Action3Command{concreteActor}
	actor.action()
}

/*
Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты,
позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их,
а также поддерживать отмену операций.

Паттерн Команда предлагает больше не отправлять вызовы к бизнес-логике напрямую. Вместо этого каждый вызов,
отличающийся от других, следует завернуть в собственный класс с единственным методом,
который и будет осуществлять вызов. Такие объекты называют командами.

К объекту интерфейса можно будет привязать объект команды, который знает,
кому и в каком виде следует отправлять запросы. Когда объект интерфейса будет готов передать запрос,
он вызовет метод команды, а та — позаботится обо всём остальном.

Классы команд можно объединить под общим интерфейсом c единственным методом запуска.
После этого одни и те же отправители смогут работать с различными командами, не привязываясь к их классам.
Даже больше: команды можно будет взаимозаменять на лету, изменяя итоговое поведение отправителей.

Параметры, с которыми должен быть вызван метод объекта получателя, можно загодя сохранить в полях объекта-команды.
Благодаря этому, объекты, отправляющие запросы, могут не беспокоиться о том,
чтобы собрать необходимые для получателя данные. Более того, они теперь вообще не знают,
кто будет получателем запроса. Вся эта информация скрыта внутри команды.

Применимость
- Когда мы хотим параметризовать объекты выполняемым действием.

Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимозаменять внутри других объектов.

- Когда мы хотим ставить операции в очередь, выполнять их по расписанию или передавать по сети.

Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку,
чтобы потом сохранить в файл или базу данных. Затем в любой удобный момент её можно достать обратно,
снова превратить в объект команды и выполнить. Таким же образом команды можно передавать по сети,
логировать или выполнять на удалённом сервере.

- Когда нам нужна операция отмены.

Главная вещь, которая нам нужна, чтобы иметь возможность отмены операций, — это хранение истории.
Среди многих способов, которыми можно это сделать, паттерн Команда является, пожалуй, самым популярным.

История команд выглядит как стек, в который попадают все выполненные объекты команд.
Каждая команда перед выполнением операции сохраняет текущее состояние объекта, с которым она будет работать.
После выполнения операции копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта.
Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.

Этот способ имеет две особенности. Во-первых, точное состояние объектов не так-то просто сохранить,
ведь часть его может быть приватным.

Во-вторых, копии состояния могут занимать довольно много оперативной памяти.
Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния
команда выполняет обратное действие. Недостаток этого способа в сложности (а иногда и невозможности) реализации обратного действия.

Преимущества
- Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
- Позволяет реализовать простую отмену и повтор операций.
- Позволяет реализовать отложенный запуск операций.
- Позволяет собирать сложные команды из простых.
- Реализует принцип открытости/закрытости.

Недостатки
- Усложняет код программы из-за введения множества дополнительных классов.
*/
