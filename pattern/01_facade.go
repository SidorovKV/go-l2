package pattern

/*
	Реализовать паттерн «фасад».
Объяснить применимость паттерна, его плюсы и минусы,а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern
*/

type Facade struct{}

func (f *Facade) FacadeMethod() {
	a := &subSystemA{}
	b := &subSystemB{}
	a.MethodA()
	b.MethodB()
}

type subSystemA struct{}

func (s *subSystemA) MethodA() {

}

type subSystemB struct{}

func (s *subSystemB) MethodB() {

}

/*
Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов.
Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь,
используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту,
и скрывает все остальные.

Фасад может быть полезен, если мы используем какую-то сложную библиотеку со множеством подвижных частей,
но нам нужна только часть её возможностей.

Применимость
- Когда нам нужно представить простой или урезанный интерфейс к сложной подсистеме.

Часто подсистемы усложняются по мере развития программы.
Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве.
Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем,
применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы по умолчанию,
устраивающий большинство клиентов.

- Когда мы хотим разложить подсистему на отдельные слои.

Используем фасады для определения точек входа на каждый уровень подсистемы.
Если подсистемы зависят друг от друга, то зависимость можно упростить,
разрешив подсистемам обмениваться информацией только через фасады.

Преимущества
Изолирует клиентов от компонентов сложной подсистемы.

Недостатки
Фасад рискует стать "божественным объектом", привязанным ко всем классам программы.
*/
