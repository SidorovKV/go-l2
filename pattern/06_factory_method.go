package pattern

import "fmt"

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

type Blacksmith interface {
	CreateWeapon() Weapon
}

type Weapon interface {
	CauseDamage()
}

type Sword struct{}

func (s *Sword) CauseDamage() {
	fmt.Println("Sword causes some damage")
}

type Axe struct{}

func (a *Axe) CauseDamage() {
	fmt.Println("Axe causes some damage")
}

type Bow struct{}

func (b *Bow) CauseDamage() {
	fmt.Println("Bow causes some damage")
}

type SwordSmith struct{}

func (ss *SwordSmith) CreateWeapon() Weapon {
	return &Sword{}
}

type AxeSmith struct{}

func (as *AxeSmith) CreateWeapon() Weapon {
	return &Axe{}
}

type BowSmith struct{}

func (bs *BowSmith) CreateWeapon() Weapon {
	return &Bow{}
}

type Smithy struct {
	ss *SwordSmith
	as *AxeSmith
	bs *BowSmith
}

func (s *Smithy) CreateWeapon(weaponType string) Weapon {
	switch weaponType {
	case "sword":
		return s.ss.CreateWeapon()
	case "axe":
		return s.as.CreateWeapon()
	case "bow":
		return s.bs.CreateWeapon()
	default:
		fmt.Println("Weapon type not supported")
		return nil
	}
}

func FactoryMethodExample() {
	smithy := &Smithy{
		ss: &SwordSmith{},
		as: &AxeSmith{},
		bs: &BowSmith{},
	}

	sword := smithy.CreateWeapon("sword")
	axe := smithy.CreateWeapon("axe")
	bow := smithy.CreateWeapon("bow")

	sword.CauseDamage()
	axe.CauseDamage()
	bow.CauseDamage()
}

/*
Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new,
а через вызов особого фабричного метода. Объекты всё равно будут создаваться при помощи new,
но делать это будет фабричный метод.

На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора
из одного конца программы в другой. Но теперь мы сможем переопределить фабричный метод в подклассе,
чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс.
Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

Применимость
- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать наш код.

Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.

Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта,
нам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

- Когда мы хотим экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими,
как подключение к базе данных, файловой системе и т. д.

Представим, сколько действий мам нужно совершить, чтобы повторно использовать существующие объекты:

1. Сначала нам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
2. При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
3. А затем вернуть его клиентскому коду.
4. Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.
Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов.
Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

Преимущества
- Избавляет класс от привязки к конкретным классам продуктов.
- Выделяет код производства продуктов в одно место, упрощая поддержку кода.
- Упрощает добавление новых продуктов в программу.
- Реализует принцип открытости/закрытости.

Недостатки
- Может привести к созданию больших параллельных иерархий классов,
так как для каждого класса продукта надо создать свой подкласс создателя.
*/
